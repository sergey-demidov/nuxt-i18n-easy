const path = require('path')
const fs = require('fs')
const querystring = require('querystring')
const endOfLine = require('os').EOL
const minimatch = require('minimatch')
const consola = require('consola')
const axios = require('axios')
const inquirer = require('inquirer')
const esmImport = require('esm')(module)
// const _ = require('lodash')

const lib = {}

lib.processSentences = async (phrases, sourceLanguage, locale) => {
  const translations = lib.importFile(locale.langFile) || {}
  const result = {}
  const exist = Object.keys(translations)
  let diffs = phrases.filter(x => !exist.includes(x))
  // console.dir(diffs)
  if (diffs.length === 0) {
    consola.info(`\x1B[36m${locale.langFile}\x1B[0m up to date`)
    return null
  }
  diffs = diffs.sort().filter((item, index, ar) => {
    return !index || item !== ar[index - 1]
  })
  const unused = exist.filter(x => !phrases.includes(x))
  const opts = []
  for (const key of diffs) {
    const res = await lib.translate(sourceLanguage, locale.translationCode, key)
    translations[key] = res.translated
    if (res.opts.length) {
      opts[key] = res.opts
    }
  }
  Object.keys(translations).forEach((key) => {
    const res = {}
    res.translated = translations[key]
    res.unused = unused.includes(key)
    res.opts = Array.isArray(opts[key]) ? opts[key].join(', ') : ''
    result[key] = res
  })
  return result
}

// Welcome: 'Welcome' // 123 Welcome!·

lib.writeConfig = (locale, sentences) => {
  const lines = []
  Object.keys(sentences).forEach((key, index) => {
    let line = '  '
    line += key.match(/^[a-zA-Z_][a-zA-Z_\d]+$/) ? key : `'${key}'`
    line += `: '${sentences[key].translated}'`
    if (index !== Object.keys(sentences).length - 1) {
      line += ','
    }
    if (sentences[key].opts || sentences[key].unused) {
      line += ' // '
      if (sentences[key].opts) { line += sentences[key].opts }
      if (sentences[key].unused) { line += ' # unused' }
    }
    // console.dir(line)
    lines.push(line)
  })
  const out = `// generated by nuxt-i18n-easy${endOfLine}export default {${endOfLine}` +
                        lines.join(endOfLine) + `${endOfLine}}${endOfLine}`
  if (fs.existsSync(locale.langFile) && fs.statSync(locale.langFile).size > 0) {
    fs.copyFileSync(locale.langFile, locale.langFile + '.' + new Date().toISOString().slice(0, 16).replace(/[T:]/g, '-'))
  }
  fs.writeFileSync(locale.langFile, out)
  return out
}

lib.checkFiles = async (config) => {
  if (!fs.existsSync(config.langDir)) {
    consola.log(`\u{1F527} Directory ${config.langDir} does not exist `)
    await inquirer.prompt([
      {
        name: 'dir',
        type: 'confirm',
        message: 'Do you wish to create it?'
      }, {
        when (answers) {
          // console.dir(answers)
          // console.trace()
          if (answers.dir) {
            fs.mkdirSync(path.join(process.cwd(), config.langDir))
          } else {
            return false
          }
        }
      }])
    if (!fs.existsSync(config.langDir)) {
      consola.error(lib.directoryWarn(config.langDir))
      return false
    }
  }
  // console.log('End of dir prompt')
  for (const locale of config.locales) {
    const langFile = path.join(config.langDir, locale.file)
    if (!fs.existsSync(langFile)) {
      consola.log(`\u{1F527} File ${langFile} does not exist `)
      await inquirer.prompt([
        {
          name: 'file',
          type: 'confirm',
          message: 'Do you wish to create it?'
        }, {
          when (answers) {
            if (answers.file) {
              fs.writeFileSync(path.join(process.cwd(), langFile), '')
              // console.dir(res)
            } else {
              return false
            }
          }
        }
      ])
      if (!fs.existsSync(langFile)) {
        consola.error(`File ${langFile} does not exist`)
        consola.info(`Tip: You may need to run\n\n
                \x1B[36m touch ${langFile} \x1B[0m\n\n`)
        return false
      }
    }
    // console.log('End of file prompt')
  }
  return true
}

lib.getConfig = (nuxtConfig, config) => {
  let i18n
  if (nuxtConfig.i18n instanceof Object) {
    i18n = nuxtConfig.i18n
  } else if (Array.isArray(nuxtConfig.modules)) {
    for (const module of nuxtConfig.modules) {
      if (module.includes('nuxt-i18n')) {
        i18n = module[1]
      }
    }
  }
  if (!(i18n instanceof Object)) {
    consola.error(`No \x1B[36mi18n\x1B[0m config detected.${lib.example}${lib.URL}`)
    return
  }
  // if (_.isEmpty(i18n)) {
  //   consola.error(`No \x1B[36mi18n\x1B[0m config detected.\n${lib.example}\n${lib.URL}`)
  //   return
  // }
  if (Array.isArray(i18n.locales) && i18n.locales.length > 0) {
    config.locales = i18n.locales.slice()
  }
  if (typeof i18n.langDir === 'string') {
    config.langDir = i18n.langDir
  } else {
    consola.error(`Property \x1B[36mi18n.langDir\x1B[0m is not defined${lib.example}${lib.URL}`)
    return
  }
  if (config.locales.length === 0) {
    consola.error(`No \x1B[36mi18n\x1B[0m locales detected.\nYou must specify one or more locales.${lib.example}${lib.URL}`)
    return
  }
  if (nuxtConfig.i18nEasy instanceof Object) {
    if (Array.isArray(nuxtConfig.i18nEasy.directories) && nuxtConfig.i18nEasy.directories.length > 0) {
      config.directories = nuxtConfig.i18nEasy.directories
    }
    if (Array.isArray(nuxtConfig.i18nEasy.files) && nuxtConfig.i18nEasy.files.length > 0) {
      config.fileMask = nuxtConfig.i18nEasy.files
    }
    if (typeof nuxtConfig.i18nEasy.sourceLanguage === 'string') {
      config.sourceLanguage = nuxtConfig.i18nEasy.sourceLanguage
    }
  }
  for (const locale of config.locales) {
    if (!locale.code) {
      consola.error(`Property \x1B[36mcode\x1B[0m for i18n locale not defined.${lib.example}${lib.URL} `)
      return
    }
    if (!locale.file) {
      consola.error(`Property \x1B[36mfile\x1B[0m for locale \x1B[36m${locale.code}\x1B[0m not defined.${lib.example}${lib.URL} `)
      return
    }
    if (typeof locale.translationCode !== 'string') {
      locale.translationCode = locale.code
    }
    // locale.langFile = path.join(process.cwd(), config.langDir, locale.file)
    locale.langFile = path.join(config.langDir, locale.file)
  }
  return config
}

lib.importFile = (fileName) => {
  try {
    return esmImport(path.join(process.cwd(), fileName)).default
  } catch (e) {
    consola.error(`Cant import file \x1B[36m${fileName}\x1B[0m.${lib.URL}`)
    // consola.error(e)
    return null
  }
}

lib.translate = async (from, to, sentence) => {
  let opts = []
  if (to === from) {
    consola.info(`Skip translation from \x1B[36m${from}\x1B[0m to \x1B[36m${to}\x1B[0m`)
    return { translated: sentence, opts }
  }
  const requestString = querystring.stringify({
    client: 'gtx',
    ie: 'UTF-8',
    oe: 'UTF-8',
    dt: ['t', 'at', 'bd'],
    // dt: ['bd', 'ex', 'ld', 'md', 'rw', 'rm', 'ss', 't', 'at', 'gt', 'qca'],
    hl: 'en',
    sl: from,
    tl: to,
    q: sentence.trim()
  })
  const res = await axios.get('http://translate.googleapis.com/translate_a/single?' + requestString, {
    headers: { Accept: '*/*' }
  })
  // if (process.env.DEBUG === 'true') { console.dir(res.data, { depth: 10 }) }
  // console.dir(res.data, { depth: 10 })
  let translated = ''
  if (res.data[0] && res.data[0][0]) {
    for (const ph of res.data[0]) {
      if (ph[0] === null) {
        break
      } else {
        translated += ph[0]
      }
    }
  }
  if (res.data[1] && res.data[1][0]) {
    opts = res.data[1][0][1] || []
  }
  if (translated.length > 0) {
    const startSpace = sentence.match(/^(\s+)/)
    if (startSpace) {
      translated += startSpace[1]
    }
    const endSpace = sentence.match(/(\s+)$/)
    if (endSpace) {
      translated = endSpace[1] + translated
    }
    consola.success(`'${sentence}' => '${translated}'`)
    return { translated, opts }
  } else {
    consola.error('\x1B[31mTranslation error\x1B[0m')
    // eslint-disable-next-line no-console
    // if (process.env.DEBUG === 'true') { console.dir(res.data, { depth: 10 }) }
    return { translated: sentence, opts }
  }
}

lib.getSentences = (dirs, fileMask) => {
  const phrases = []
  for (const dir of dirs) {
    if (fs.existsSync(dir)) {
      const files = lib.getFiles(dir, fileMask)
      for (const file of files) {
        const lines = fs.readFileSync(file, 'utf-8').split(endOfLine).join('')
        const regexp = [
          /"([^"]+)"\.tr\(\)/g, /'([^']+)'\.tr\(\)/g,
          /\$t\('([^']+)'\)/g, /\$t\("([^"]+)"\)/g,
          /v-tr[^>]*>\s*([^<]+[^ ])\s*</g]
        for (const reg of regexp) {
          let matches
          while ((matches = reg.exec(lines)) != null) {
            const sanitized = matches[1].replace(/&#(\d+);/g, (match, dec) => {
              return String.fromCharCode(dec)
            })
            phrases.push(sanitized)
          }
        }
      }
    } else {
      consola.warn(`Cant open directory \x1B[36m${dir}\x1B[0m, possible typo in \x1B[36m\x1B[4mnuxt.nuxtConfig.js\x1B[0m\x1B[0m`)
    }
  }
  return phrases
}

lib.URL = '\nPlease refer documentation on https://github.com/sergey-demidov/nuxt-i18n-easy\n'

lib.phrasesWarn = `No words or phrases found for translation
Try to add to your project something like this:

     \x1B[36m $t('Welcome') \x1B[0m
            or
     \x1B[36m 'Inspire'.tr()\x1B[0m
            or
\x1B[36m <p v-tr> I will be translated </p> \x1B[0m

`
lib.example = `\nExample \x1B[4mnuxt.nuxt.js\x1B[0m :\n
\x1B[90mexport default {\x1B[36m
  modules: [
    'nuxt-i18n',
    'nuxt-i18n-easy'
  ],
  i18n: {
    locales: [
      {
        code: 'en',
        name: 'English',
        file: 'en.js',
      },
      {
        code: 'ru',
        name: 'Русский',
        file: 'ru.js',
      }
    ],
    lazy: true,
    langDir: 'lang/'
  },
  i18nEasy: {
    directories: [                // default directories for search
      './layouts',
      './pages',
      './components'
    ],
    files: ['*.vue', '*.js'],     // default files
    sourceLanguage: 'en'          // default source language
  },
  \x1B[90m\n...\n\x1B[0m

`

lib.getFiles = (root, masks) => {
  if (!Array.isArray(masks)) {
    if (typeof masks === 'string') {
      masks = [masks]
    } else {
      return []
    }
  }
  let res = []
  const files = fs.readdirSync(root)
  files.forEach((file) => {
    const filename = path.join(root, file)
    const stat = fs.lstatSync(filename)
    if (stat.isDirectory()) {
      res = res.concat(lib.getFiles(filename, masks)) // recursive
    } else {
      masks.forEach((mask) => {
        if (minimatch(file, mask)) {
          res.push(filename)
        }
      })
    }
  })
  return res
}

lib.directoryWarn = (langDir) => {
  return `Directory \x1B[36m${langDir}\x1B[0m dos not exist.
You need to create this directory

\x1B[36m            mkdir ${langDir} \x1B[0m

or specify it correctly in \x1B[4m\x1B[4mnuxt.nuxtConfig.js\x1B[0m\x1B[0m${lib.URL}`
}

module.exports = lib
