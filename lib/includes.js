const path = require('path')
const fs = require('fs')
const querystring = require('querystring')
const endOfLine = require('os').EOL
const Module = require('module')
const minimatch = require('minimatch')
const consola = require('consola')
const axios = require('axios')
const inquirer = require('inquirer')
const { loadNuxt } = require('nuxt')

// const esmImport = require('esm')(module)
// const _ = require('lodash')
// const babel = require('@babel/core')

const lib = {}

lib.config = {
  directories: [
    './layouts',
    './pages',
    './components'
  ],
  fileMask: ['*.vue', '*.js'],
  sourceLanguage: 'en',
  locales: [],
  langDir: '',
  lang: process.argv[2] || ''
}

lib.loadConfig = async () => {
  const nuxt = await loadNuxt('dev')
  return lib.clone(nuxt.options)
}

lib.processSentences = async (phrases, sourceLanguage, locale) => {
  const translations = lib.importFile(locale.langFile) || {}
  const exist = Object.keys(translations)
  let diffs = phrases.filter(x => !exist.includes(x))
  if (diffs.length === 0) {
    consola.info(`\x1B[36m${locale.langFile}\x1B[0m up to date`)
    return null
  }
  diffs = diffs.sort().filter((item, index, ar) => {
    return !index || item !== ar[index - 1]
  })
  const unused = exist.filter(x => !phrases.includes(x))
  for (const phrase of diffs) {
    const res = await lib.translateV1(sourceLanguage, locale.translationCode, phrase)
    if (res.length > 0) {
      translations[phrase] = res
      console.dir(translations)
    }
  }
  for (const key in translations) {
    if (unused.includes(key)) {
      translations[key].push('unused')
    }
  }
  return lib.clone(translations)
}

lib.writeConfig = (locale, sentences) => {
  const lines = []
  Object.keys(sentences).forEach((key, index) => {
    let line = '  '
    sentences[key][0] = sentences[key][0].replace(/'/g, "\\'")
    const keyEscaped = key.replace(/'/g, "\\'")
    line += keyEscaped.match(/^[a-zA-Z_][a-zA-Z_\d]+$/) ? keyEscaped : `'${keyEscaped}'`
    line += `: '${sentences[key][0]}'`
    if (index !== Object.keys(sentences).length - 1) {
      line += ','
    }
    if (sentences[key][1]) {
      for (const i in sentences[key]) {
        if (i !== 0) {
          line += ' // ' + sentences[key][i]
        }
      }
    }
    // console.dir(line)
    lines.push(line)
  })
  const out = '// generated by nuxt-i18n-easy' + endOfLine +
    'export default {' + endOfLine +
    lines.join(endOfLine) + endOfLine +
    '};' + endOfLine
  if (fs.existsSync(locale.langFile) && fs.statSync(locale.langFile).size > 0) {
    fs.copyFileSync(locale.langFile, locale.langFile + '.' + new Date().toISOString().slice(0, 16).replace(/[T:]/g, '-'))
  }
  fs.writeFileSync(locale.langFile, out)
  return out
}

lib.checkFiles = async () => {
  if (!fs.existsSync(lib.config.langDir)) {
    consola.log(`\u{1F527} Directory ${lib.config.langDir} does not exist `)
    await inquirer.prompt([
      {
        name: 'dir',
        type: 'confirm',
        message: 'Do you wish to create it?'
      }, {
        when (answers) {
          // console.dir(answers)
          // console.trace()
          if (answers.dir) {
            fs.mkdirSync(path.join(process.cwd(), lib.config.langDir))
          } else {
            return false
          }
        }
      }])
    if (!fs.existsSync(lib.config.langDir)) {
      consola.error(lib.directoryWarn(lib.config.langDir))
      return false
    }
  }
  // console.log('End of dir prompt')
  for (const locale of lib.config.locales) {
    const langFile = path.join(lib.config.langDir, locale.file)
    if (!fs.existsSync(langFile)) {
      consola.log(`\u{1F527} File ${langFile} does not exist `)
      await inquirer.prompt([
        {
          name: 'file',
          type: 'confirm',
          message: 'Do you wish to create it?'
        }, {
          when (answers) {
            if (answers.file) {
              fs.writeFileSync(path.join(process.cwd(), langFile), '')
              // console.dir(res)
            } else {
              return false
            }
          }
        }
      ])
      if (!fs.existsSync(langFile)) {
        consola.error(`File ${langFile} does not exist`)
        consola.info(`Tip: You may need to run\n\n
                \x1B[36m touch ${langFile} \x1B[0m\n\n`)
        return false
      }
    }
    // console.log('End of file prompt')
  }
  return true
}

lib.clone = (source) => {
  return JSON.parse(JSON.stringify(source))
}

lib.getConfig = (nuxtConfig) => {
  let i18n
  if (typeof nuxtConfig.i18n === 'object') {
    i18n = lib.clone(nuxtConfig.i18n)
  } else if (Array.isArray(nuxtConfig.modules)) {
    for (const module of nuxtConfig.modules) {
      if (module.includes('nuxt-i18n')) {
        i18n = lib.clone(module[1])
      }
    }
  }
  if (typeof i18n !== 'object') {
    consola.error(`No \x1B[36mi18n\x1B[0m config detected.${lib.example}${lib.URL}`)
    return
  }
  // if (_.isEmpty(i18n)) {
  //   consola.error(`No \x1B[36mi18n\x1B[0m config detected.\n${lib.example}\n${lib.URL}`)
  //   return
  // }
  if (Array.isArray(i18n.locales) && i18n.locales.length > 0) {
    lib.config.locales = lib.clone(i18n.locales)
  }
  if (typeof i18n.langDir === 'string') {
    lib.config.langDir = i18n.langDir
  } else {
    consola.error(`Property \x1B[36mi18n.langDir\x1B[0m is not defined${lib.example}${lib.URL}`)
    return
  }
  if (lib.config.locales.length === 0) {
    consola.error(`No \x1B[36mi18n\x1B[0m locales detected.\nYou must specify one or more locales.${lib.example}${lib.URL}`)
    return
  }
  if (typeof nuxtConfig.i18nEasy === 'object') {
    if (Array.isArray(nuxtConfig.i18nEasy.directories) && nuxtConfig.i18nEasy.directories.length > 0) {
      lib.config.directories = nuxtConfig.i18nEasy.directories
    }
    if (Array.isArray(nuxtConfig.i18nEasy.files) && nuxtConfig.i18nEasy.files.length > 0) {
      lib.config.fileMask = nuxtConfig.i18nEasy.files
    }
    if (typeof nuxtConfig.i18nEasy.sourceLanguage === 'string') {
      lib.config.sourceLanguage = nuxtConfig.i18nEasy.sourceLanguage
    }
  }
  lib.config.projectId = 'YOUR_PROJECT_ID'
  for (const locale of lib.config.locales) {
    // console.dir(locale)
    if (!locale.code) {
      consola.error(`Property \x1B[36mcode\x1B[0m for i18n locale not defined.${lib.example}${lib.URL} `)
      return
    }
    if (!locale.file) {
      consola.error(`Property \x1B[36mfile\x1B[0m for locale \x1B[36m${locale.code}\x1B[0m not defined.${lib.example}${lib.URL} `)
      return
    }
    if (typeof locale.translationCode !== 'string') {
      locale.translationCode = locale.code
    }
    // locale.langFile = path.join(process.cwd(), config.langDir, locale.file)
    locale.langFile = path.join(lib.config.langDir, locale.file)
  }
  return lib.config
}

lib.importFile = (fileName) => {
  try {
    const file = path.join(process.cwd(), fileName)
    if (fs.statSync(file).size === 0) {
      return {}
    } else {
      const entry = fs.readFileSync(file, 'utf-8')
      const source = entry.replace(/export default/, 'module.exports.default = ')
      const m = new Module('', undefined)
      m._compile(source, 'file.js')
      const res = m.exports.default
      const ret = {}
      for (const key in res) {
        ret[key] = [res[key]]
      }
      return ret
    }
  } catch (e) {
    consola.error(e.message)
    return {}
  }
}

lib.translateV2 = async (from, to, sentence) => {
  if (to === from) {
    consola.info(`Skip translation from \x1B[36m${from}\x1B[0m to \x1B[36m${to}\x1B[0m`)
    return [sentence]
  }
  const { Translate } = require('@google-cloud/translate').v2
  const translate = new Translate({ projectId: '' })
  const options = { from, to }
  let res
  try {
    [res] = await translate.translate(sentence.trim(), options)
    res = Array.isArray(res) ? res : [res]
    res.forEach((tr, i) => {
      consola.success(`${sentence} => (${to}) ${tr}`)
    })
  } catch (err) {
    consola.error(err.message)
    return []
  }
  // if (process.env.DEBUG === 'true') { console.dir(res.data, { depth: 10 }) }
  // console.dir(res.data, { depth: 10 })
  if (res[0].length > 0) {
    const startSpace = sentence.match(/^(\s+)/)
    if (startSpace) {
      res[0] = startSpace[1] + res[0]
    }
    const endSpace = sentence.match(/(\s+)$/)
    if (endSpace) {
      res[0] += endSpace[1]
    }
    consola.success(`'${sentence}' => '${res[0]}'`)
    return res
  } else {
    consola.error('\x1B[31mTranslation error\x1B[0m')
    return []
  }
}
lib.translateV1 = async (from, to, sentence) => {
  if (to === from) {
    consola.info(`Skip translation from \x1B[36m${from}\x1B[0m to \x1B[36m${to}\x1B[0m`)
    return [sentence]
  }
  const requestString = querystring.stringify({
    client: 'gtx',
    ie: 'UTF-8',
    oe: 'UTF-8',
    dt: ['t', 'at', 'bd'],
    // dt: ['bd', 'ex', 'ld', 'md', 'rw', 'rm', 'ss', 't', 'at', 'gt', 'qca'],
    hl: 'en',
    sl: from,
    tl: to,
    q: sentence.trim()
  })
  let res
  try {
    res = await axios.get('http://translate.googleapis.com/translate_a/single?' + requestString, {
      headers: { Accept: '*/*' }
    })
  } catch (err) {
    consola.error(err.message)
    return []
  }
  // if (process.env.DEBUG === 'true') { console.dir(res.data, { depth: 10 }) }
  // console.dir(res.data, { depth: 10 })
  let translated = ''
  if (res.data[0] && res.data[0][0]) {
    for (const ph of res.data[0]) {
      if (ph[0] === null) {
        break
      } else {
        translated += ph[0]
      }
    }
  }
  if (translated.length > 0) {
    const startSpace = sentence.match(/^(\s+)/)
    if (startSpace) {
      translated = startSpace[1] + translated
    }
    const endSpace = sentence.match(/(\s+)$/)
    if (endSpace) {
      translated += endSpace[1]
    }
    consola.success(`'${sentence}' => '${translated}'`)
    let ret = [translated]
    if (res.data[1] && res.data[1][0] && res.data[1][0][1]) {
      ret = [translated].concat(res.data[1][0][1])
    }
    return ret
  } else {
    consola.error('\x1B[31mTranslation error\x1B[0m')
    // eslint-disable-next-line no-console
    // if (process.env.DEBUG === 'true') { console.dir(res.data, { depth: 10 }) }
    return []
  }
}

lib.getSentences = (dirs, fileMask) => {
  const phrases = []
  for (const dir of dirs) {
    if (fs.existsSync(dir)) {
      const files = lib.getFiles(dir, fileMask)
      for (const file of files) {
        const lines = fs.readFileSync(file, 'utf-8').split(endOfLine).join('')
        const regexp = [
          /"([^"]+)"\.tr\(\)/g, /'([^']+)'\.tr\(\)/g,
          /\$t\('([^']+)'\)/g, /\$t\("([^"]+)"\)/g,
          /v-tr[^>]*>\s*([^<]+[^ ])\s*</g]
        for (const reg of regexp) {
          let matches
          while ((matches = reg.exec(lines)) != null) {
            let sanitized = matches[1].replace(/&#(\d+);/g, (match, dec) => {
              return String.fromCharCode(dec)
            })
            sanitized = sanitized.replace(/\\\\/g, '\\')
            phrases.push(sanitized.trim())
          }
        }
      }
    } else {
      consola.warn(`Cant open directory \x1B[36m${dir}\x1B[0m, possible typo in \x1B[36m\x1B[4mnuxt.nuxtConfig.js\x1B[0m\x1B[0m`)
    }
  }
  return phrases
}

lib.URL = '\nPlease refer documentation on https://github.com/sergey-demidov/nuxt-i18n-easy\n'

lib.phrasesWarn = `No words or phrases found for translation
Try to add to your project something like this:

     \x1B[36m $t('Welcome') \x1B[0m
            or
     \x1B[36m 'Inspire'.tr()\x1B[0m
            or
\x1B[36m <p v-tr> I will be translated </p> \x1B[0m

and run this script again
`
lib.example = `\nExample \x1B[4mnuxt.nuxt.js\x1B[0m :\n
\x1B[90mexport default {\x1B[36m
  modules: [
    'nuxt-i18n',
    'nuxt-i18n-easy'
  ],
  i18n: {
    locales: [
      {
        code: 'en',
        name: 'English',
        file: 'en.js',
      },
      {
        code: 'ru',
        name: 'Русский',
        file: 'ru.js',
      }
    ],
    lazy: true,
    langDir: 'lang/'
  },
  i18nEasy: {
    directories: [                // default directories for search
      './layouts',
      './pages',
      './components'
    ],
    files: ['*.vue', '*.js'],     // default files
    sourceLanguage: 'en'          // default source language
  },
  \x1B[90m\n...\n\x1B[0m

`

lib.getFiles = (root, masks) => {
  if (!Array.isArray(masks)) {
    if (typeof masks === 'string') {
      masks = [masks]
    } else {
      return []
    }
  }
  let res = []
  const files = fs.readdirSync(root)
  files.forEach((file) => {
    const filename = path.join(root, file)
    const stat = fs.lstatSync(filename)
    if (stat.isDirectory()) {
      res = res.concat(lib.getFiles(filename, masks)) // recursive
    } else {
      masks.forEach((mask) => {
        if (minimatch(file, mask)) {
          res.push(filename)
        }
      })
    }
  })
  return res
}

lib.directoryWarn = (langDir) => {
  return `Directory \x1B[36m${langDir}\x1B[0m dos not exist.
You need to create this directory

\x1B[36m            mkdir ${langDir} \x1B[0m

or specify it correctly in \x1B[4m\x1B[4mnuxt.nuxtConfig.js\x1B[0m\x1B[0m${lib.URL}`
}

module.exports = lib
